(in-package :game-level)

(defun id-matrix (dims)
  (let ((array (make-array (* dims dims) :initial-element 0.0 :element-type 'single-float)))
    (dotimes (d dims)
      (setf (aref array (* d (1+ dims))) 1.0))
    array))

(defun mat* (m1 m2)
  (let ((new (make-array 16 :initial-element 0.0 :element-type 'single-float)))
    (dotimes (x 4)
      (dotimes (y 4)
        (let ((prod (+ (* (aref m1 (* x 4)) (aref m2 y))
                       (* (aref m1 (+ (* x 4) 1)) (aref m2 (+ y 4)))
                       (* (aref m1 (+ (* x 4) 2)) (aref m2 (+ y 8)))
                       (* (aref m1 (+ (* x 4) 3)) (aref m2 (+ y 12))))))
          (setf (aref new (+ y (* x 4))) (coerce prod 'single-float)))))
    new))

(defun m-perspective (fov aspect z-near z-far)
  (let* ((xymax (* z-near (tan (* fov 0.00872664625))))
         (ymin (- xymax))
         (xmin (- xymax))
         (width (- xymax xmin))
         (height (- xymax ymin))
         (depth (- z-far z-near))
         (q (/ (- (+ z-far z-near)) depth))
         (qn (/ (* -2 z-far z-near) depth))
         (w (/ (/ (* 2 z-near) width) aspect))
         (h (/ (* 2 z-near) height))
         (matrix (make-array 16 :initial-element 0.0 :element-type 'single-float)))
    (setf (aref matrix 0)  w
          (aref matrix 5)  h
          (aref matrix 10) q
          (aref matrix 11) -1.0
          (aref matrix 14) qn)
    matrix))

(defun m-rotate (x y z theta-degrees)
  (let* ((matrix (id-matrix 4))
         (angle-rad (* (mod theta-degrees 360) (/ 3.14159 180)))
         (x2 (* x x))
         (y2 (* y y))
         (z2 (* z z))
         (cos (coerce (cos angle-rad) 'double-float))
         (sin (coerce (sin angle-rad) 'double-float))
         (icos (- 1 cos))
         (icos-xy (* icos x y))
         (icos-xz (* icos x z))
         (icos-yz (* icos y z))
         (x-sin (* x sin))
         (y-sin (* y sin))
         (z-sin (* z sin)))
    (setf (aref matrix 0)  (coerce (+ (* x2 icos) cos)  'single-float)
          (aref matrix 1)  (coerce (- icos-xy z-sin) 'single-float)
          (aref matrix 2)  (coerce (+ icos-xz y-sin) 'single-float)
          (aref matrix 4)  (coerce (+ icos-xy z-sin) 'single-float)
          (aref matrix 5)  (coerce (+ (* y2 icos) cos) 'single-float)
          (aref matrix 6)  (coerce (- icos-yz x-sin) 'single-float)
          (aref matrix 8)  (coerce (- icos-xz y-sin) 'single-float)
          (aref matrix 9)  (coerce (+ icos-yz x-sin) 'single-float)
          (aref matrix 10) (coerce (+ (* z2 icos) cos) 'single-float))
    matrix))

(defun m-scale (x y z)
  (let ((matrix (id-matrix 4)))
    (setf (aref matrix 0)  (coerce x 'single-float)
          (aref matrix 5)  (coerce y 'single-float)
          (aref matrix 10) (coerce z 'single-float))
    matrix))
  
(defun m-translate (x y z)
  (let ((translatrix (id-matrix 4)))
    (setf (aref translatrix 12) (coerce x 'single-float)
          (aref translatrix 13) (coerce y 'single-float)
          (aref translatrix 14) (coerce z 'single-float))
    translatrix))

